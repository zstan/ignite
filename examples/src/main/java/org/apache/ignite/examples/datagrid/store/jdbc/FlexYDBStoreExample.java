package org.apache.ignite.examples.datagrid.store.jdbc;

import static org.apache.ignite.cache.CacheAtomicityMode.TRANSACTIONAL;

import java.util.List;
import java.util.UUID;
import org.apache.ignite.Ignite;
import org.apache.ignite.IgniteCache;
import org.apache.ignite.IgniteException;
import org.apache.ignite.Ignition;
import org.apache.ignite.cache.query.FieldsQueryCursor;
import org.apache.ignite.cache.query.SqlFieldsQuery;
import org.apache.ignite.configuration.CacheConfiguration;
import org.apache.ignite.examples.ExampleNodeStartup;
import org.apache.ignite.examples.ExamplesUtils;
import org.apache.ignite.transactions.Transaction;

/**
 * Demonstrates usage of cache with underlying persistent store configured.
 * <p>
 * This example uses {@link CacheJdbcPersonStore} as a persistent store.
 * <p>
 * To start the example, you should:
 * <ul>
 *     <li>Start a few nodes using {@link ExampleNodeStartup}.</li>
 *     <li>Start example using {@link FlexYDBStoreExample}.</li>
 * </ul>
 * <p>
 * Remote nodes can be started with {@link ExampleNodeStartup} in another JVM which will
 * start node with {@code examples/config/example-ignite.xml} configuration.
 */
public class FlexYDBStoreExample {
    /** Cache name. */
    private static final String CACHE_NAME = CacheJdbcStoreExample.class.getSimpleName();

    /** Heap size required to run this example. */
    public static final int MIN_MEMORY = 1024 * 1024 * 1024;

    /** Number of entries to load. */
    private static final int ENTRY_COUNT = 100_000;

    /** Global person ID to use across entire example. */
    private static final Long id = Math.abs(UUID.randomUUID().getLeastSignificantBits());

    /**
     * Executes example.
     *
     * @param args Command line arguments, none required.
     * @throws IgniteException If example execution failed.
     */
    public static void main(String[] args) throws IgniteException {
        ExamplesUtils.checkMinMemory(MIN_MEMORY);

        // To start ignite with desired configuration uncomment the appropriate line.
        try (Ignite ignite = Ignition.start("examples/config/example-ignite.xml")) {
            System.out.println();
            System.out.println(">>> Cache store example started.");

            CacheConfiguration cacheCfg = new CacheConfiguration<>(CACHE_NAME);

            // Set atomicity as transaction, since we are showing transactions in example.
            cacheCfg.setAtomicityMode(TRANSACTIONAL);

            YDBStoreFactory<Integer, FlexHolder> factory = new YDBStoreFactory<>();
            factory.setConnectionUrl("grpc://localhost:2136/local");
            factory.setCacheName("SQL_PUBLIC_FLEX"); // can be autogenerated from sql "create table", hardcoded for now
            cacheCfg.setCacheStoreFactory(factory);

            cacheCfg.setReadThrough(true);
            cacheCfg.setWriteThrough(true);

            // Auto-close cache at the end of the example.
            try (IgniteCache<Long, FlexHolder> cache = ignite.getOrCreateCache(cacheCfg)) {
                ignite.cache(CACHE_NAME).query(new SqlFieldsQuery("drop table if exists flex;"));

                FieldsQueryCursor<List<?>> res0 = ignite.cache(CACHE_NAME)
                        .query(new SqlFieldsQuery("create table if not exists flex(id long primary key, val int not null, sval varchar);"));

                res0.getAll();

                // Make initial cache loading from persistent store. This is a
                // distributed operation and will call CacheStore.loadCache(...)
                // method on all nodes in topology.
                loadCache(cache);

                // Start transaction and execute several cache operations with
                // read/write-through to persistent store.
                executeTransaction(cache);
            }
            finally {
                // Distributed cache could be removed from cluster only by #destroyCache() call.
                ignite.destroyCache(CACHE_NAME);
            }
        }
    }

    /**
     * Makes initial cache loading.
     *
     * @param cache Cache to load.
     */
    private static void loadCache(IgniteCache<Long, FlexHolder> cache) {
        long start = System.currentTimeMillis();

        // Start loading cache from persistent store on all caching nodes.
        cache.loadCache(null, ENTRY_COUNT);

        long end = System.currentTimeMillis();

        System.out.println(">>> Loaded " + cache.size() + " keys with backups in " + (end - start) + "ms.");
    }

    /**
     * Executes transaction with read/write-through to persistent store.
     *
     * @param cache Cache to execute transaction on.
     */
    private static void executeTransaction(IgniteCache<Long, FlexHolder> cache) {
        try (Transaction tx = Ignition.ignite().transactions().txStart()) {
            FlexHolder val = cache.get(id);

            System.out.println("Read value: " + val);

            val = cache.getAndPut(id, new FlexHolder(100, "test"));

            System.out.println("Overwrite old value: " + val);

            val = cache.get(id);

            System.out.println("Read value: " + val);

            tx.commit();
        }

        // Clear entry from memory, but keep it in store.
        cache.clear(id);

        // Operations on this cache will not affect store.
        IgniteCache<Long, FlexHolder> cacheSkipStore = cache.withSkipStore();

        System.out.println("Read value skipping store (expecting null): " + cacheSkipStore.get(id));

        System.out.println("Read value with store lookup (expecting NOT null): " + cache.get(id));

        // Expecting not null, since entry should be in memory since last call.
        System.out.println("Read value skipping store (expecting NOT null): " + cacheSkipStore.get(id));

        // Clear entry from memory, and from store.
        cache.remove(id);

        System.out.println("Key removes elsewhere (expecting null): " + cache.get(id));
    }
}
